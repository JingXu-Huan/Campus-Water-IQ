# 告警服务开发手册

## 一、模块定位与设计理念

告警服务是物联网系统中的**风险放大器与第一响应者**。
它不判断数据是否“有意义”，只负责一件事：**当异常被确认存在时，确保它被准确、及时、可追溯地传递出去**。

一句话总结：

>告警服务负责让异常“被看见”。

---

## 二、模块核心职责

告警服务主要承担以下职责：

1. **消费数据接入层推送的异常消息**，不直接接触原始设备数据。
2. 对告警消息进行**统一建模、标准化处理**。
3. 根据异常类型与严重程度，执行**告警分级与路由策略**。
4. 将告警信息可靠地推送至：
    * 告警展示系统
    * 通知系统（短信 / 邮件 / WebHook 等）
5. 对告警全过程进行**持久化存储**，支持事后审计与复盘。

---

## 三、告警接入方式

### 3.1 接入模型说明

告警服务通过 **消息队列（MQ）** 接收来自数据接入层的异常事件：

* 告警服务 **只消费异常消息**
* 不参与任何数据校验、物理规则判断
* 不回写设备状态

> 原则：告警服务永远相信“异常已经被确认过”。

---

### 3.2 告警 Topic 约定（来自接入层）

| 异常类型              | Topic             |
|-------------------|-------------------|
| 异常水流量             | `error-flow`      |
| 异常水温              | `error-tem`       |
| 异常水压力             | `error-pres`      |
| 水质 pH 异常          | `error-ph`        |
| 浊度异常              | `error-turbidity` |
| 余氯异常              | `error-chlorine`  |
| 来自service的，后续开发补充 | `error-xxxxxx`    |

> Topic 体现“异常事实”，不体现处理策略。

---

### 3.3 消费者组命名规范

* Consumer Group：`Alarm-Service-ConsumerGroup`
* 一个告警服务实例集群共享同一 Consumer Group

---

## 四、告警消息模型规范

### 4.1 标准告警消息结构

告警消息必须包含以下字段：

```json
{
  "deviceCode": "",
  "deviceType": 1,
  "alarmType": "FLOW_OUT_OF_RANGE",
  "alarmLevel": "WARN",
  "occurTime": "2026-01-09T10:12:30Z",
  "originalValue": 0.42,
  "ruleCode": "FLOW_MAX_LIMIT",
  "sourceTopic": "error-flow",
  "ext": {
    "Min": 0,
    "Max": 0.35
  }
}
```

### 4.2 字段语义说明

* `alarmType`：异常的**业务语义标识**
* `ruleCode`：触发异常的**规则唯一标识**
* `alarmLevel`：异常严重级别（见下）
* `ext`：扩展上下文信息，用于前端展示或二次处理

> 告警不是一句“出事了”，而是一份完整的事故现场记录。

---

## 五、告警等级设计

### 5.1 告警等级定义

| 等级    | 含义            |
|-------|---------------|
| INFO  | 轻微异常，仅记录      |
| WARN  | 需要关注，可能影响业务   |
| ERROR | 明确故障，需介入处理    |
| FATAL | 严重异常，可能引发连锁问题 |

### 5.2 等级判定原则

* 告警等级 **由数据接入层初步给出**
* 告警服务可根据配置进行**二次映射**
* 不允许在告警服务中“重新计算规则”

---

## 六、告警处理流程

### 6.1 核心处理流程

1. 消费 MQ 告警消息
2. 校验告警消息结构完整性
3. 标准化与补充元信息
4. 告警持久化
5. 执行告警路由策略
6. 推送至下游系统(第三方服务)

---

### 6.2 幂等性与去重策略

* 幂等 Key 建议：

  ```
  deviceCode + alarmType + occurTime
  ```
* 同一异常在短时间内重复上报：

    * 可配置**告警抑制窗口**
    * 防止“**告警风暴**”

> 告警太多，等于没有告警。

---

## 七、告警路由与通知策略

### 7.1 路由维度

告警路由可基于以下维度配置：
* 设备类型
* 告警类型
* 告警等级
* 时间段（如夜间告警升级）

### 7.2 通知方式（可扩展）

* WebSocket 实时推送
* 邮件
* 短信
* 企业微信 / 钉钉

> 告警服务不关心你怎么被吵醒，只负责保证你一定会被吵醒。

---

## 八、告警存储设计

### 8.1 告警表核心字段

* 告警唯一 ID
* 设备信息
* 告警类型 / 等级
* 触发时间
* 是否已确认
* 确认人 / 确认时间

### 8.2 生命周期管理

* 未确认告警：永久保留
* 已确认告警：可按策略归档
* 支持告警关闭、误报标记

---

## 九、失败处理与可靠性保障

### 9.1 消费失败处理

* MQ 消费失败 → 重试
* 超过最大重试次数 → 死信队列
* 死信必须可追溯、可回放

### 9.2 系统自我监控

告警服务必须暴露以下指标：

* 告警消费失败次数
* 告警发送失败率
* 告警堆积数量

> 一个不监控自己的告警系统，本身就是最大的告警源。

---

## 十、边界与约束

告警服务 **绝不做** 以下事情：

* ❌ 校验设备数据物理合理性
* ❌ 修改设备运行状态
* ❌ 推断业务原因
* ❌ 参与复杂规则计算

它只做一件事：
**把已经确认的异常，准确、快速、完整地传递出去。**
---
